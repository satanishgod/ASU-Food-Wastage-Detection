# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-tRnKBVyM6lMffrUclmGpGbQeY8JxIFq
"""

# app.py
!pip install streamlit ultralytics
import streamlit as st
from ultralytics import YOLO
import tempfile
import cv2
from PIL import Image
import numpy as np

# Load the trained YOLOv8 model
model = YOLO('best.pt')  # Place your best.pt in the same folder

# App UI
st.set_page_config(page_title="üçî Food Waste Detector", layout="centered")
st.title("üçΩÔ∏è Food Waste Detection App")
st.write("Upload an image OR use webcam to detect food waste items!")

# File uploader or Webcam selector
option = st.radio("Choose Input Method:", ('Upload Image', 'Use Webcam'))

# Function to make prediction
def predict_image(image_np):
    with tempfile.NamedTemporaryFile(delete=False, suffix=".jpg") as tmp_file:
        img = Image.fromarray(image_np)
        img.save(tmp_file.name)
        results = model.predict(source=tmp_file.name, save=False)
    return results

# Upload image option
if option == 'Upload Image':
    uploaded_file = st.file_uploader("Upload an image", type=["jpg", "jpeg", "png"])
    if uploaded_file is not None:
        image = Image.open(uploaded_file)
        st.image(image, caption='Uploaded Image', use_column_width=True)

        image_np = np.array(image)

        with st.spinner('üîç Detecting...'):
            results = predict_image(image_np)

        # Show detection
        st.subheader("üîé Detection Results:")
        results[0].show()

        # Print Detected classes
        if results[0].boxes.cls.numel() > 0:
            class_ids = results[0].boxes.cls.cpu().numpy().astype(int)
            detected_classes = [model.names[cid] for cid in class_ids]
            st.success(f"Detected Food Items: {', '.join(set(detected_classes))}")
        else:
            st.warning("No food items detected.")

# Webcam option
elif option == 'Use Webcam':
    stframe = st.empty()
    cap = cv2.VideoCapture(0)

    if not cap.isOpened():
        st.error("Webcam not accessible. Please check your camera permissions.")
    else:
        st.info('Click "Stop Webcam" to end.')

    run = st.button('Stop Webcam')

    while cap.isOpened() and not run:
        ret, frame = cap.read()
        if not ret:
            st.error("Failed to grab frame.")
            break

        frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)

        with st.spinner('üîç Detecting...'):
            results = predict_image(frame_rgb)

        # Draw detection boxes
        annotated_frame = results[0].plot()

        stframe.image(annotated_frame, channels="BGR", use_column_width=True)

        # Stop if user clicks button
        run = st.button('Stop Webcam')

    cap.release()
    st.success('Webcam stopped.')